import io
import json
import os
import zipfile
from enum import Enum
from json import dumps

import requests

try:
    from rich.console import Console
    from rich.progress import track
    from rich.status import Status
    from typer import Typer, Option, Argument, Exit
except ImportError:
    print("Please install malwarebazaar[cli] if you want to use the cli functionality.")
    raise

from malwarebazaar.api import Yaraify
from malwarebazaar.config import Config, YARAifyConfig
from malwarebazaar.models import Sample, YaraRule, Task
from malwarebazaar.output import print_sample_table, print_yararule_table, print_task_table, yara_csv_output
from malwarebazaar.util import check_version


class QueryTypes(Enum):
    hash = "hash"
    yara = "yara"
    clamav = "clamav"
    imphash = "imphash"
    gimphash = "gimphash"
    icon = "icon"
    tlsh = "tlsh"
    telfhash = "telfhash"


yaraify_app = Typer(name="YARAify cli", help="Query YARAify from your command line!")


@yaraify_app.command(name="init", help="Initialize YARAify cli.")
def init(
        bazaar_key: str = Option(None, "-b", "--bazaar", help="Optional MalwareBazaar key."),
        malpedia_key: str = Option(None, "-m", "--malpedia",
                                   help="Optional Malpedia key to use for yara rule searches."),
        api_key: str = Argument(..., help="The API key from your YARAify account.")
):
    c = Console()
    try:
        conf = Config.get_instance()
    except FileNotFoundError:
        Config.init_config(
            bazaar_key,
            api_key,
            malpedia_key
        )
        conf = Config.get_instance()

    # Do not overwrite MalwareBazaar key with None
    if bazaar_key:
        conf.api_key = bazaar_key

    conf.yaraify = YARAifyConfig(
        api_key=api_key,
        malpedia_key=malpedia_key
    )
    conf.save_config()
    c.print("Successfully created config:")
    c.print(conf.json())


@yaraify_app.command(name="query", help="Query the YARAify API.")
def query(
        json: bool = Option(False, "-j", "--json", help="Output raw JSON response."),
        limit: int = Option(25, "-l", "--limit", help="Limit the amount of objects returned."),
        simple: bool = Option(False, "-s", "--simple", help="Just output SHA256 hashes."),
        query_type: QueryTypes = Argument(..., show_choices=True, help="The type of query to send to the API."),
        download: bool = Option(False, "-d", "--download", help="Download samples retrieved by query."),
        query: str = Argument(..., help="The search term to use.")
):
    c, ec = Console(), Console(stderr=True)
    config = Config.get_instance()
    yaraify = Yaraify(
        api_key=config.yaraify.api_key,
        malpedia_key=config.yaraify.malpedia_key
    )

    with Status("Querying YARAify..."):
        if query_type == QueryTypes.hash:
            data = yaraify.query_hash(query)
        elif query_type == QueryTypes.yara:
            data = yaraify.query_yara_rule(query, limit)
        elif query_type == QueryTypes.clamav:
            data = yaraify.query_clamav_signature(query, limit)
        elif query_type == QueryTypes.imphash:
            data = yaraify.query_imphash(query, limit)
        elif query_type == QueryTypes.gimphash:
            data = yaraify.query_gimphash(query, limit)
        elif query_type == QueryTypes.icon:
            data = yaraify.query_icon_dhash(query, limit)
        elif query_type == QueryTypes.tlsh:
            data = yaraify.query_tlsh(query, limit)
        elif query_type == QueryTypes.telfhash:
            data = yaraify.query_telfhash(query, limit)
        else:
            ec.print("[bold red]Currently only \"hash\" as query type is supported.[/bold red]")
            raise Exit(-1)

    if data["query_status"] != "ok":
        ec.print(f"[bold red]API returned with an error: {data['query_status']}[/bold red]")
        raise Exit(-1)

    if json:
        c.print(dumps(data, indent=4))
    else:
        data = data["data"]
        sample_list = [data] if isinstance(data, dict) else data
        for idx, sample_dict in enumerate(sample_list):
            tasks = None
            if "metadata" in sample_dict:
                tasks = sample_dict["tasks"]
                sample_dict = sample_dict["metadata"]

            if simple:
                c.print(sample_dict["sha256_hash"])
            else:
                sample = Sample(**sample_dict)
                c.print(f"Sample {idx + 1}/{len(sample_list)}")
                print_sample_table(sample, c)
                if tasks:
                    for idx, task in enumerate(tasks):
                        t = Task(**task)
                        c.print(f"Task {idx + 1}/{len(tasks)}")
                        print_task_table(t, c, include_sample=False)
                c.print()

        if download:
            for sample in track(sample_list, description="Downloading samples..."):
                if "metadata" in sample:
                    sample = sample["metadata"]
                sha256_hash = sample["sha256_hash"]
                file_content = yaraify.download_file(sha256_hash)
                with io.open(sha256_hash, "wb") as fh:
                    fh.write(file_content)


@yaraify_app.command(name="recent", help="Query for recent Yara rules.")
def recent_yara(
        json: bool = Option(False, "-j", "--json", help="Output raw JSON response."),
        simple: bool = Option(False, "-s", "--simple", help="Just print Yara rule names and the rule UUIDs."),
        csv: bool = Option(False, "-c", "--csv", help="CSV output.")
):
    c, ec = Console(), Console(stderr=True)
    config = Config.get_instance()
    yaraify = Yaraify(config.yaraify.api_key, config.yaraify.malpedia_key)
    data = yaraify.query_recent_yara()

    if data["query_status"] != "ok":
        ec.print(f"[bold red]API returned with an error: {data['query_status']}[/bold red]")
        raise Exit(-1)

    if json:
        c.print(dumps(data, indent=4))
    else:
        data = data["data"]
        rules = [YaraRule(**r) for r in data]
        if csv:
            yara_csv_output(rules, c)
        else:
            for idx, r in enumerate(rules):
                if simple:
                    c.print(f"{r.rule_name} ({r.yarahub_uuid})")
                else:
                    c.print(f"{idx + 1}/{len(rules)}")
                    print_yararule_table(r, c)
                    c.print()


@yaraify_app.command(name="get", help="Fetch Yara rule by its UUID")
def get_rule(
        uuid: str = Argument(..., help="YARAhub UUID"),
        filename: str = Argument(None, help="Filename to write Yara rule into.")
):
    c, ec = Console(), Console(stderr=True)
    config = Config.get_instance()
    yaraify = Yaraify(config.yaraify.api_key, config.yaraify.malpedia_key)
    rule = yaraify.download_yara(uuid)
    if rule[0] == "{":
        data = json.loads(rule)
        if data["query_status"] == "error":
            ec.print(f"[bold red]{data['data']}[/bold red]")
            raise Exit(-1)
        else:
            ec.print(f"Unknown JSON returned:")
            ec.print(data)
            raise Exit(-1)
    c.print(rule)
    if filename:
        with io.open(filename, "w") as fh:
            fh.write(rule)


@yaraify_app.command(name="download", help="Download all TLP:CLEAR YARAify rules.")
def download_rules(
        unzip: bool = Option(False, "-u", "--unzip", help="Unzip the downloaded archive of rules"),
        filename: str = Argument(None, help="Optional filename.")
):
    c, ec = Console(), Console(stderr=True)
    if not filename:
        filename = "yaraify-rules.zip"
    with Status("Downloading rules...") as status:
        response = requests.get(Yaraify.ROOTURL + "download/yaraify-rules.zip", stream=True)
        if response.status_code != 200:
            ec.print(f"[bold red]Unexpected HTTP status code: {response.status_code}")
            raise Exit(-1)
        for chunk in response.iter_content(chunk_size=1024 ** 2):
            with io.open(filename, "wb") as fh:
                fh.write(chunk)
        if unzip:
            status.update(status="Unzipping rules...")
            os.mkdir("yaraify-rules")
            zf = zipfile.ZipFile(filename)
            if not os.path.exists("yaraify-rules"):
                ec.print("[bold red]Could not create directory \"yaraify-rules\".")
                raise Exit(-1)
            zf.extractall("yaraify-rules")
            os.remove(filename)
    if unzip:
        listing = os.listdir("yaraify-rules")
        c.print(f"Downloaded {len(listing)} Yara rules.")
    else:
        c.print(f"Downloaded rule archive to {filename}.")


@yaraify_app.command(name="task", help="Fetch task results")
def get_task(
        json: bool = Option(False, "-j", "--json", help="Output raw JSON response"),
        uuid: str = Argument(..., help="Task (UU)ID")
):
    c, ec = Console(), Console(stderr=True)
    config = Config.get_instance()
    yaraify = Yaraify(config.yaraify.api_key, config.yaraify.malpedia_key)
    data = yaraify.query_task(uuid)

    if data["query_status"] != "ok":
        ec.print(f"[bold red]API returned with an error: {data['query_status']}[/bold red]")
        raise Exit(-1)

    if json:
        c.print(dumps(data, indent=4))
    else:
        data = data["data"]
        if isinstance(data, str):
            if data == "queued":
                ec.print(f"[yellow]Task is currently queued.[/yellow]")
                raise Exit(0)
            else:
                ec.print(f"[bold red]API returned an unexpected string: {data}.")
                raise Exit(-1)
        task = Task(**data)
        print_task_table(task, c)


@yaraify_app.command(name="version", help="Print and check yaraify version.")
def version(
        check: bool = Option(False, "-c", "--check", help="Check if you're using the latest version via Github API.")
):
    check_version(check)


if __name__ == "__main__":
    yaraify_app()
